# utils.py
import os
import sqlglot
from langchain_community.utilities.sql_database import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain_community.tools import QuerySQLDatabaseTool
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import PromptTemplate
from langchain_core.runnables.config import RunnableConfig


def connect_to_sql(db_path: str):
    if not os.path.isfile(db_path):
        raise FileNotFoundError(f"‚ùå Database file not found at: {db_path}")
    return SQLDatabase.from_uri(f"sqlite:///{db_path}")

def get_chain(question, db_path):
    llm = OllamaLLM(model="deepseek-coder:6.7b", temperature=0.0, max_tokens=512)
    db = connect_to_sql(db_path)
    table_info = db.get_table_info()
    top_k = 5

    # Log available tables and columns for debugging
    print("üîé Available Tables:", db.get_table_names())
    for t in db.get_table_names():
        try:
            col_info = db.run(f"PRAGMA table_info({t});")
            print(f"üìã Columns in {t}: {col_info}")
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to get columns for table {t}: {e}")

    # Prompt to generate a raw SQL query from the user's question and table info
    prompt = PromptTemplate.from_template("""
    You are a SQLite expert.

    Given this database schema:
    {table_info}

    Answer the following question by writing a syntactically correct SQL query for SQLite.
    DO NOT include explanations or comments ‚Äî only return the raw SQL query.
    Only use the exact table and column names shown in the schema.

    Question: {question}
    SQLQuery:
    """)

    query_chain = prompt | llm | StrOutputParser()
    execute_query = QuerySQLDatabaseTool(db=db)

    try:
        config = RunnableConfig(run_name="streamlit_sql_validation")

        # Step 1: Generate SQL query
        generated_query = query_chain.invoke({
            "question": question,
            "table_info": table_info,
            "top_k": top_k
        })

        # Step 2: Validate SQL
        try:
            sqlglot.parse_one(generated_query)
        except sqlglot.errors.ParseError as e:
            print("‚ùå Invalid SQL generated:", generated_query)
            return {
                "sql_query": generated_query,
                "result": "",
                "answer": f"‚ùå Invalid SQL generated by the model: {e}"
            }

        # Step 3: Execute and return result or error
        try:
            sql_result = execute_query.invoke(generated_query)
        except Exception as e:
            return {
                "sql_query": generated_query,
                "result": "",
                "answer": f"‚ùå SQL execution failed: {e}"
            }

        return {
            "sql_query": generated_query,
            "result": sql_result,
            "answer": sql_result
        }

    except Exception as e:
        import traceback
        traceback.print_exc()
        return {
            "sql_query": "",
            "result": "",
            "answer": f"‚ùå Failed during chain execution: {e}"
        }
